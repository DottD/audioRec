#ifndef AudioProcess_hpp
#define AudioProcess_hpp

//#include <QApplication>
#include <QDir>
#include <QSharedPointer>
#include <QRunnable>
#include <QThread>
#include <QString>
#include <QVector>
#include <QImage>
#include <QSize>
#include <armadillo>
#include <UMF/functions.hpp>
#include <AA/Application.hpp>
#include <AA/AudioReader.hpp>

#ifndef QSHARED_QDIR_META_DEF
#define QSHARED_QDIR_META_DEF
Q_DECLARE_METATYPE(QSharedPointer<QDir>)
#endif

#ifndef QSHARED_QVEC_META_DEF
#define QSHARED_QVEC_META_DEF
Q_DECLARE_METATYPE(QSharedPointer<QVector<double>>)
#endif

#ifndef QSHARED_QVECVEC_META_DEF
#define QSHARED_QVECVEC_META_DEF
Q_DECLARE_METATYPE(QSharedPointer<QVector<QVector<double>>>)
#endif

#ifndef QSHARED_QIMAGE_META_DEF
#define QSHARED_QIMAGE_META_DEF
Q_DECLARE_METATYPE(QSharedPointer<QImage>)
#endif

#ifndef QSHARED_AUDIOREADER_META_DEF
#define QSHARED_AUDIOREADER_META_DEF
Q_DECLARE_METATYPE(QSharedPointer<Ui::AudioReader>)
#endif

namespace Ui {
	class AudioProcess;
}

#include <GUI/ChartRecWidget.hpp>

/** Class to process an audio file supporting multithreading.
 This class is both a QObject and a QRunnable, so that it can be executed in QThreadPool,
 but it is also able to signal that the process has ended, and that some notable series
 has been computed, allowing them to be exploited in other threads.
 */
class Ui::AudioProcess : public QObject, public QRunnable {
	Q_OBJECT
	
private:
	QObject* Caller; /**< Caller object (by now only ChartRecWidget are allowed). */
	QSharedPointer<QDir> dir; /**< Path to the audio file */
	QSharedPointer<QImage> corr; /**< Final image generated by the signal processing. */
	QSharedPointer<AudioReader> reader; /**< AudioReader instance to store audio information. */
	// Define some constant value
	bool computeAll = true; /**< Set to true if the computation of every record is required. */
	unsigned int computeOnlyIdx = 0; /**< When computeAll is false, contains the index of the record to be computed. */
	QSharedPointer<QVector<QVector<double>>> features; /**< The features computed during the process. */
	
	QSharedPointer<QVector<double>> armaToQ(const arma::vec& vec) const; /**< Function to convert vectors from arma to Qt style */
	
public:
	AudioProcess(QObject* parent = Q_NULLPTR) : QObject(parent) {
		qRegisterMetaType<QSharedPointer<QDir>>();
		qRegisterMetaType<QSharedPointer<QImage>>();
		qRegisterMetaType<QSharedPointer<QVector<double>>>();
		qRegisterMetaType<QSharedPointer<QVector<QVector<double>>>>();
		qRegisterMetaType<QSharedPointer<AudioReader>>();
		
		// In order to avoid errors, always initialize features
		features = QSharedPointer<QVector<QVector<double>>>(new QVector<QVector<double>>);
	}; /**< Constructor with parent argument (same as QObject one) */
	
	void setFileName(QSharedPointer<QDir>); /**< Setter for the fileName property */
	QDir getFileName() const {return *dir;}; /**< Getter for the fileName property */
	
	void setCaller(QObject* obj) {this->Caller = obj;}; /**< Setter for the Caller property */
	QObject* getCaller() {return this->Caller;}; /**< Getter for the Caller property */
	
	void setReader(QSharedPointer<AudioReader> reader) {this->reader = reader;} /**< Set AudioReader with already loaded file. */
	QSharedPointer<AudioReader> getReader() {return this->reader;} /**< Get the AudioReader of this instance. */
	
	void setComputeAll() {this->computeAll = true;} /**< Instruct to compute every record */
	bool getComputeAll() {return this->computeAll;} /**< Return whether the instance has to compute every record or not */
	
	void setComputeOnly(unsigned int idx) {this->computeOnlyIdx = idx; this->computeAll = false;} /**< Instruct to compute only the given record */
	unsigned int getComputeOnly() {return this->computeOnlyIdx;} /**< Get which record the instance has been instructed to compute */
	
	QSharedPointer<QVector<QVector<double>>> getFeatures(){return this->features;}; /**< Returns the features computed */
	
	/** Reimplementation of the run method.
	 This is the main function of the class: it performs all required operations on the file
	 associated with the class instance.
	 */
	void run();
	
signals:
	void processEnded(QSharedPointer<QDir>); /**< Signal emitted at the end of the run method */
	
	void notableSeries(QSharedPointer<QVector<double>>); /**< Signal emitted when an important operation is performed on samples */
	
	void notableSpectrum(QSharedPointer<QVector<double>>); /**< Signal emitted when an important operation is performed on spectrum */
	
	void raiseError(QString errorMsg); /**< Signal emitted when an error occurs */
	
	void audioLoaded(QSharedPointer<AudioReader>); /**< Signal emitted when the audio file is loaded */
	
	void imageGenerated(QSharedPointer<QDir>, QSharedPointer<QImage>); /**< Signal emitted when a new image has been generated */
	
	void newFeatures(QSharedPointer<QDir>, QSharedPointer<QVector<QVector<double>>>); /**< Signal emitted when a new features vector has been generated. */
};

#endif /* AudioProcess_hpp */
